searchNodes=[{"ref":"Fintech.html","title":"Fintech","type":"module","doc":"Fintech keeps the contexts that define your domain and business logic. Contexts are also responsible for managing your data, regardless if it comes from the database, an external API or others."},{"ref":"Fintech.Accounts.html","title":"Fintech.Accounts","type":"module","doc":"The Accounts context."},{"ref":"Fintech.Accounts.html#change_account/1","title":"Fintech.Accounts.change_account/1","type":"function","doc":"Returns an %Ecto.Changeset{} for tracking account changes. Examples iex&gt; change_account(account) %Ecto.Changeset{source: %Account{}}"},{"ref":"Fintech.Accounts.html#create_account/1","title":"Fintech.Accounts.create_account/1","type":"function","doc":"Creates a account. Examples iex&gt; create_account(%{field: value}) {:ok, %Account{}} iex&gt; create_account(%{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Accounts.html#delete_account/1","title":"Fintech.Accounts.delete_account/1","type":"function","doc":"Deletes a Account. Examples iex&gt; delete_account(account) {:ok, %Account{}} iex&gt; delete_account(account) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Accounts.html#get_account!/1","title":"Fintech.Accounts.get_account!/1","type":"function","doc":"Gets a single account. Raises Ecto.NoResultsError if the Account does not exist. Examples iex&gt; get_account!(123) %Account{} iex&gt; get_account!(456) ** (Ecto.NoResultsError)"},{"ref":"Fintech.Accounts.html#list_accounts/0","title":"Fintech.Accounts.list_accounts/0","type":"function","doc":"Returns the list of accounts. Examples iex&gt; list_accounts() [%Account{}, ...]"},{"ref":"Fintech.Accounts.html#update_account/2","title":"Fintech.Accounts.update_account/2","type":"function","doc":"Updates a account. Examples iex&gt; update_account(account, %{field: new_value}) {:ok, %Account{}} iex&gt; update_account(account, %{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Accounts.Account.html","title":"Fintech.Accounts.Account","type":"module","doc":""},{"ref":"Fintech.Banks.html","title":"Fintech.Banks","type":"module","doc":"The Banks context."},{"ref":"Fintech.Banks.html#change_bank/1","title":"Fintech.Banks.change_bank/1","type":"function","doc":"Returns an %Ecto.Changeset{} for tracking bank changes. Examples iex&gt; change_bank(bank) %Ecto.Changeset{source: %Bank{}}"},{"ref":"Fintech.Banks.html#create_bank/1","title":"Fintech.Banks.create_bank/1","type":"function","doc":"Creates a bank. Examples iex&gt; create_bank(%{field: value}) {:ok, %Bank{}} iex&gt; create_bank(%{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Banks.html#delete_bank/1","title":"Fintech.Banks.delete_bank/1","type":"function","doc":"Deletes a Bank. Examples iex&gt; delete_bank(bank) {:ok, %Bank{}} iex&gt; delete_bank(bank) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Banks.html#get_bank!/1","title":"Fintech.Banks.get_bank!/1","type":"function","doc":"Gets a single bank. Raises Ecto.NoResultsError if the Bank does not exist. Examples iex&gt; get_bank!(123) %Bank{} iex&gt; get_bank!(456) ** (Ecto.NoResultsError)"},{"ref":"Fintech.Banks.html#list_banks/0","title":"Fintech.Banks.list_banks/0","type":"function","doc":"Returns the list of banks. Examples iex&gt; list_banks() [%Bank{}, ...]"},{"ref":"Fintech.Banks.html#update_bank/2","title":"Fintech.Banks.update_bank/2","type":"function","doc":"Updates a bank. Examples iex&gt; update_bank(bank, %{field: new_value}) {:ok, %Bank{}} iex&gt; update_bank(bank, %{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Banks.Bank.html","title":"Fintech.Banks.Bank","type":"module","doc":""},{"ref":"Fintech.Customers.html","title":"Fintech.Customers","type":"module","doc":"The Customers context."},{"ref":"Fintech.Customers.html#change_customer/1","title":"Fintech.Customers.change_customer/1","type":"function","doc":"Returns an %Ecto.Changeset{} for tracking customer changes. Examples iex&gt; change_customer(customer) %Ecto.Changeset{source: %Customer{}}"},{"ref":"Fintech.Customers.html#create_customer/1","title":"Fintech.Customers.create_customer/1","type":"function","doc":"Creates a customer. Examples iex&gt; create_customer(%{field: value}) {:ok, %Customer{}} iex&gt; create_customer(%{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Customers.html#delete_customer/1","title":"Fintech.Customers.delete_customer/1","type":"function","doc":"Deletes a Customer. Examples iex&gt; delete_customer(customer) {:ok, %Customer{}} iex&gt; delete_customer(customer) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Customers.html#get_customer!/1","title":"Fintech.Customers.get_customer!/1","type":"function","doc":"Gets a single customer. Raises Ecto.NoResultsError if the Customer does not exist. Examples iex&gt; get_customer!(123) %Customer{} iex&gt; get_customer!(456) ** (Ecto.NoResultsError)"},{"ref":"Fintech.Customers.html#list_customers/0","title":"Fintech.Customers.list_customers/0","type":"function","doc":"Returns the list of customers. Examples iex&gt; list_customers() [%Customer{}, ...]"},{"ref":"Fintech.Customers.html#update_customer/2","title":"Fintech.Customers.update_customer/2","type":"function","doc":"Updates a customer. Examples iex&gt; update_customer(customer, %{field: new_value}) {:ok, %Customer{}} iex&gt; update_customer(customer, %{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Customers.Customer.html","title":"Fintech.Customers.Customer","type":"module","doc":""},{"ref":"Fintech.Instrumenter.html","title":"Fintech.Instrumenter","type":"module","doc":"This module provides the metrics for the fintech company"},{"ref":"Fintech.Instrumenter.html#handle_event/4","title":"Fintech.Instrumenter.handle_event/4","type":"function","doc":"Function for handling of telemetry events"},{"ref":"Fintech.Instrumenter.html#log_metrics/2","title":"Fintech.Instrumenter.log_metrics/2","type":"function","doc":"Function for inspecting the events from telemetry"},{"ref":"Fintech.Instrumenter.html#setup/0","title":"Fintech.Instrumenter.setup/0","type":"function","doc":"Function to setup telemetry"},{"ref":"Fintech.Repo.html","title":"Fintech.Repo","type":"module","doc":""},{"ref":"Fintech.Repo.html#aggregate/4","title":"Fintech.Repo.aggregate/4","type":"function","doc":"Calculate the given aggregate over the given field. If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result. Any preload or select in the query will be ignored in favor of the column being aggregated. The aggregation will fail if any group_by field is set. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Examples # Returns the number of visits per blog post Repo.aggregate(Post, :count, :visits) # Returns the number of visits per blog post in the &quot;private&quot; schema path # (in Postgres) or database (in MySQL) Repo.aggregate(Post, :count, :visits, prefix: &quot;private&quot;) # Returns the average number of visits for the top 10 query = from Post, limit: 10 Repo.aggregate(query, :avg, :visits) Callback implementation for Ecto.Repo.aggregate/4."},{"ref":"Fintech.Repo.html#all/2","title":"Fintech.Repo.all/2","type":"function","doc":"Fetches all entries from the data store matching the given query. May raise Ecto.QueryError if query validation fails. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example # Fetch all post titles query = from p in Post, select: p.title MyRepo.all(query) Callback implementation for Ecto.Repo.all/2."},{"ref":"Fintech.Repo.html#checkout/2","title":"Fintech.Repo.checkout/2","type":"function","doc":"Checks out a connection for the duration of the function. It returns the result of the function. This is useful when you need to perform multiple operations against the repository in a row and you want to avoid checking out the connection multiple times. checkout/2 and transaction/2 can be combined and nested multiple times. If checkout/2 is called inside the function of another checkout/2 call, the function is simply executed, without checking out a new connection. Options See the &quot;Shared options&quot; section at the module documentation for more options. Callback implementation for Ecto.Repo.checkout/2."},{"ref":"Fintech.Repo.html#child_spec/1","title":"Fintech.Repo.child_spec/1","type":"function","doc":""},{"ref":"Fintech.Repo.html#config/0","title":"Fintech.Repo.config/0","type":"function","doc":"Returns the adapter configuration stored in the :otp_app environment. If the c:init/2 callback is implemented in the repository, it will be invoked with the first argument set to :runtime. Callback implementation for Ecto.Repo.config/0."},{"ref":"Fintech.Repo.html#delete/2","title":"Fintech.Repo.delete/2","type":"function","doc":"Deletes a struct using its primary key. If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised. If the struct has been removed from db prior to call, Ecto.StaleEntryError will be raised. It returns {:ok, struct} if the struct has been successfully deleted or {:error, changeset} if there was a validation or a known constraint error. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. See the &quot;Shared options&quot; section at the module documentation for more options. Example post = MyRepo.get!(Post, 42) case MyRepo.delete post do {:ok, struct} -&gt; # Deleted with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.delete/2."},{"ref":"Fintech.Repo.html#delete!/2","title":"Fintech.Repo.delete!/2","type":"function","doc":"Same as c:delete/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.delete!/2."},{"ref":"Fintech.Repo.html#delete_all/2","title":"Fintech.Repo.delete_all/2","type":"function","doc":"Deletes all entries matching the given query. It returns a tuple containing the number of entries and any returned result as second element. The second element is nil by default unless a select is supplied in the delete query. Note, however, not all databases support returning data from DELETEs. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.delete_all(Post) from(p in Post, where: p.id &lt; 10) |&gt; MyRepo.delete_all Callback implementation for Ecto.Repo.delete_all/2."},{"ref":"Fintech.Repo.html#exists?/2","title":"Fintech.Repo.exists?/2","type":"function","doc":"Checks if there exists an entry that matches the given query. Returns a boolean. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Examples # checks if any posts exist Repo.exists?(Post) # checks if any posts exist in the &quot;private&quot; schema path (in Postgres) or # database (in MySQL) Repo.exists?(Post, schema: &quot;private&quot;) # checks if any post with a like count greater than 10 exists query = from p in Post, where: p.like_count &gt; 10 Repo.exists?(query) Callback implementation for Ecto.Repo.exists?/2."},{"ref":"Fintech.Repo.html#get/3","title":"Fintech.Repo.get/3","type":"function","doc":"Fetches a single struct from the data store where the primary key matches the given id. Returns nil if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get(Post, 42) MyRepo.get(Post, 42, prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get/3."},{"ref":"Fintech.Repo.html#get!/3","title":"Fintech.Repo.get!/3","type":"function","doc":"Similar to c:get/3 but raises Ecto.NoResultsError if no record was found. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get!(Post, 42) MyRepo.get!(Post, 42, prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get!/3."},{"ref":"Fintech.Repo.html#get_by/3","title":"Fintech.Repo.get_by/3","type":"function","doc":"Fetches a single result from the query. Returns nil if no result was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get_by(Post, title: &quot;My post&quot;) MyRepo.get_by(Post, [title: &quot;My post&quot;], prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get_by/3."},{"ref":"Fintech.Repo.html#get_by!/3","title":"Fintech.Repo.get_by!/3","type":"function","doc":"Similar to c:get_by/3 but raises Ecto.NoResultsError if no record was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get_by!(Post, title: &quot;My post&quot;) MyRepo.get_by!(Post, [title: &quot;My post&quot;], prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get_by!/3."},{"ref":"Fintech.Repo.html#get_dynamic_repo/0","title":"Fintech.Repo.get_dynamic_repo/0","type":"function","doc":"Returns the atom name or pid of the current repository. See c:put_dynamic_repo/1 for more information. Callback implementation for Ecto.Repo.get_dynamic_repo/0."},{"ref":"Fintech.Repo.html#in_transaction?/0","title":"Fintech.Repo.in_transaction?/0","type":"function","doc":"Returns true if the current process is inside a transaction. If you are using the Ecto.Adapters.SQL.Sandbox in tests, note that even though each test is inside a transaction, in_transaction?/0 will only return true inside transactions explicitly created with transaction/2. This is done so the test environment mimics dev and prod. If you are trying to debug transaction-related code while using Ecto.Adapters.SQL.Sandbox, it may be more helpful to configure the database to log all statements and consult those logs. Examples MyRepo.in_transaction? #=&gt; false MyRepo.transaction(fn -&gt; MyRepo.in_transaction? #=&gt; true end) Callback implementation for Ecto.Repo.in_transaction?/0."},{"ref":"Fintech.Repo.html#insert/2","title":"Fintech.Repo.insert/2","type":"function","doc":"Inserts a struct defined via Ecto.Schema or a changeset. In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset. In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database. It returns {:ok, struct} if the struct has been successfully inserted or {:error, changeset} if there was a validation or a known constraint error. Options :returning - selects which fields to return. It accepts a list of fields to be returned from the database. When true, returns all fields. When false, no extra fields are returned. It will always include all fields in read_after_writes as well as any autogenerated id. Not all databases support this option. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set any schemas. Also, the @schema_prefix for the parent record will override all default @schema_prefixs set in any child schemas for associations. :on_conflict - It may be one of :raise (the default), :nothing, :replace_all, :replace_all_except_primary_key, {:replace, fields}, a keyword list of update instructions or an Ecto.Query query for updates. See the &quot;Upserts&quot; section for more information. :conflict_target - A list of column names to verify for conflicts. It is expected those columns to have unique indexes on them that may conflict. If none is specified, the conflict target is left up to the database. May also be {:constraint, constraint_name_as_atom} in databases that support the &quot;ON CONSTRAINT&quot; expression, such as PostgreSQL. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. See the &quot;Shared options&quot; section at the module documentation for more options. Examples A typical example is calling MyRepo.insert/1 with a struct and acting on the return value: case MyRepo.insert %Post{title: &quot;Ecto is great&quot;} do {:ok, struct} -&gt; # Inserted with success {:error, changeset} -&gt; # Something went wrong end Upserts c:insert/2 provides upserts (update or inserts) via the :on_conflict option. The :on_conflict option supports the following values: :raise - raises if there is a conflicting primary key or unique index :nothing - ignores the error in case of conflicts :replace_all - replace all values on the existing row with the values in the schema/changeset, including autogenerated fields such as inserted_at and updated_at :replace_all_except_primary_key - same as above except primary keys are not replaced {:replace, fields} - replace only specific columns. This option requires conflict_target a keyword list of update instructions - such as the one given to c:update_all/3, for example: [set: [title: &quot;new title&quot;]] an Ecto.Query that will act as an UPDATE statement, such as the one given to c:update_all/3. If the struct cannot be found, Ecto.StaleEntryError will be raised. Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL. As an example, imagine :title is marked as a unique column in the database: {:ok, inserted} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}) Now we can insert with the same title but do nothing on conflicts: {:ok, ignored} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: :nothing) assert ignored.id == nil Because we used on_conflict: :nothing, instead of getting an error, we got {:ok, struct}. However the returned struct does not reflect the data in the database. One possible mechanism to detect if an insert or nothing happened in case of on_conflict: :nothing is by checking the id field. id will be nil if the field is autogenerated by the database and no insert happened. For actual upserts, where an insert or update may happen, the situation is slightly more complex, as the database does not actually inform us if an insert or update happened. Let&#39;s insert a post with the same title but use a query to update the body column in case of conflicts: # In Postgres (it requires the conflict target for updates): on_conflict = [set: [body: &quot;updated&quot;]] {:ok, updated} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: on_conflict, conflict_target: :title) # In MySQL (conflict target is not supported): on_conflict = [set: [title: &quot;updated&quot;]] {:ok, updated} = MyRepo.insert(%Post{id: inserted.id, title: &quot;updated&quot;}, on_conflict: on_conflict) In the examples above, even though it returned :ok, we do not know if we inserted new data or if we updated only the :on_conflict fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as inserted_at will point to now rather than the time the struct was actually inserted. If you need to guarantee the data in the returned struct mirrors the database, you have three options: Use on_conflict: :replace_all, although that will replace all fields in the database with the ones in the struct/changeset, including autogenerated fields such as insert_at and updated_at: MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: :replace_all, conflict_target: :title) Specify read_after_writes: true in your schema for choosing fields that are read from the database after every operation. Or pass returning: true to insert to read all fields back: MyRepo.insert(%Post{title: &quot;this is unique&quot;}, returning: true, on_conflict: on_conflict, conflict_target: :title) Alternatively, read the data again from the database in a separate query. This option requires the primary key to be generated by the database: {:ok, updated} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: on_conflict) Repo.get(Post, updated.id) Because of the inability to know if the struct is up to date or not, inserting a struct with associations and using the :on_conflict option at the same time is not recommended, as Ecto will be unable to actually track the proper status of the association. Callback implementation for Ecto.Repo.insert/2."},{"ref":"Fintech.Repo.html#insert!/2","title":"Fintech.Repo.insert!/2","type":"function","doc":"Same as c:insert/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.insert!/2."},{"ref":"Fintech.Repo.html#insert_all/3","title":"Fintech.Repo.insert_all/3","type":"function","doc":"Inserts all entries into the repository. It expects a schema module (MyApp.User) or a source (&quot;users&quot;) or both ({&quot;users&quot;, MyApp.User}) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. The keys of the entries are the field names as atoms and the value should be the respective value for the field type or, optionally, an Ecto.Query that returns a single entry with a single value. It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be nil. When a schema module is given, the entries given will be properly dumped before being sent to the database. If the schema contains an autogenerated ID field, it will be handled either at the adapter or the storage layer. However any other autogenerated value, like timestamps, won&#39;t be autogenerated when using c:insert_all/3. This is by design as this function aims to be a more direct way to insert data into the database without the conveniences of c:insert/2. This is also consistent with c:update_all/3 that does not handle timestamps as well. It is also not possible to use insert_all to insert across multiple tables, therefore associations are not supported. If a source is given, without a schema module, the given fields are passed as is to the adapter. Options :returning - selects which fields to return. When true, returns all fields in the given schema. May be a list of fields, where a struct is still returned but only with the given fields. Or false, where nothing is returned (the default). This option is not supported by all databases. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. :on_conflict - It may be one of :raise (the default), :nothing, :replace_all, :replace_all_except_primary_key, {:replace, fields}, a keyword list of update instructions or an Ecto.Query query for updates. See the &quot;Upserts&quot; section for more information. :conflict_target - A list of column names to verify for conflicts. It is expected those columns to have unique indexes on them that may conflict. If none is specified, the conflict target is left up to the database. It may also be {:constraint, constraint_name_as_atom} in databases that support the &quot;ON CONSTRAINT&quot; expression, such as PostgreSQL, or {:unsafe_fragment, binary_fragment} to pass any expression to the database without any sanitization, such as ON CONFLICT (coalesce(firstname, &quot;&quot;), coalesce(lastname, &quot;&quot;)). See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.insert_all(Post, [[title: &quot;My first post&quot;], [title: &quot;My second post&quot;]]) MyRepo.insert_all(Post, [%{title: &quot;My first post&quot;}, %{title: &quot;My second post&quot;}]) Upserts c:insert_all/3 provides upserts (update or inserts) via the :on_conflict option. The :on_conflict option supports the following values: :raise - raises if there is a conflicting primary key or unique index :nothing - ignores the error in case of conflicts :replace_all - replace all values on the existing row by the new entry, including values not sent explicitly by Ecto, such as database defaults. This option requires a schema :replace_all_except_primary_key - same as above except primary keys are not replaced. This option requires a schema {:replace, fields} - replace only specific columns. This option requires conflict_target a keyword list of update instructions - such as the one given to c:update_all/3, for example: [set: [title: &quot;new title&quot;]] an Ecto.Query that will act as an UPDATE statement, such as the one given to c:update_all/3 Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL. Return values By default, both Postgres and MySQL return the amount of entries inserted on c:insert_all/3. However, when the :on_conflict option is specified, Postgres will only return a row if it was affected while MySQL returns at least the number of entries attempted. For example, if :on_conflict is set to :nothing, Postgres will return 0 if no new entry was added while MySQL will still return the amount of entries attempted to be inserted, even if no entry was added. Even worse, if :on_conflict is query, MySQL will return the number of attempted entries plus the number of entries modified by the UPDATE query. Callback implementation for Ecto.Repo.insert_all/3."},{"ref":"Fintech.Repo.html#insert_or_update/2","title":"Fintech.Repo.insert_or_update/2","type":"function","doc":"Inserts or updates a changeset depending on whether the struct is persisted or not. The distinction whether to insert or update will be made on the Ecto.Schema.Metadata field :state. The :state is automatically set by Ecto when loading or building a schema. Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won&#39;t work: struct = %Post{id: &quot;existing_id&quot;, ...} MyRepo.insert_or_update changeset # =&gt; {:error, changeset} # id already exists Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set any schemas. Also, the @schema_prefix for the parent record will override all default @schema_prefixs set in any child schemas for associations. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. Only applies to updates. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. Only applies to updates. See the &quot;Shared options&quot; section at the module documentation for more options. Example result = case MyRepo.get(Post, id) do nil -&gt; %Post{id: id} # Post not found, we build one post -&gt; post # Post exists, let&#39;s use it end |&gt; Post.changeset(changes) |&gt; MyRepo.insert_or_update case result do {:ok, struct} -&gt; # Inserted or updated with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.insert_or_update/2."},{"ref":"Fintech.Repo.html#insert_or_update!/2","title":"Fintech.Repo.insert_or_update!/2","type":"function","doc":"Same as c:insert_or_update/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.insert_or_update!/2."},{"ref":"Fintech.Repo.html#load/2","title":"Fintech.Repo.load/2","type":"function","doc":"Loads data into a struct or a map. The first argument can be a a schema module, or a map (of types) and determines the return value: a struct or a map, respectively. The second argument data specifies fields and values that are to be loaded. It can be a map, a keyword list, or a {fields, values} tuple. Fields can be atoms or strings. Fields that are not present in the schema (or types map) are ignored. If any of the values has invalid type, an error is raised. Examples iex&gt; MyRepo.load(User, %{name: &quot;Alice&quot;, age: 25}) %User{name: &quot;Alice&quot;, age: 25} iex&gt; MyRepo.load(User, [name: &quot;Alice&quot;, age: 25]) %User{name: &quot;Alice&quot;, age: 25} data can also take form of {fields, values}: iex&gt; MyRepo.load(User, {[:name, :age], [&quot;Alice&quot;, 25]}) %User{name: &quot;Alice&quot;, age: 25, ...} The first argument can also be a types map: iex&gt; types = %{name: :string, age: :integer} iex&gt; MyRepo.load(types, %{name: &quot;Alice&quot;, age: 25}) %{name: &quot;Alice&quot;, age: 25} This function is especially useful when parsing raw query results: iex&gt; result = Ecto.Adapters.SQL.query!(MyRepo, &quot;SELECT * FROM users&quot;, []) iex&gt; Enum.map(result.rows, &amp;MyRepo.load(User, {result.columns, &amp;1})) [%User{...}, ...] Callback implementation for Ecto.Repo.load/2."},{"ref":"Fintech.Repo.html#one/2","title":"Fintech.Repo.one/2","type":"function","doc":"Fetches a single result from the query. Returns nil if no result was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Examples Repo.one(Post) Repo.one(from p in Post, where: p.like_count &gt; 10) query = from p in Post, where: p.like_count &gt; 10 Repo.one(query, prefix: &quot;private&quot;) Callback implementation for Ecto.Repo.one/2."},{"ref":"Fintech.Repo.html#one!/2","title":"Fintech.Repo.one!/2","type":"function","doc":"Similar to c:one/2 but raises Ecto.NoResultsError if no record was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Callback implementation for Ecto.Repo.one!/2."},{"ref":"Fintech.Repo.html#preload/3","title":"Fintech.Repo.preload/3","type":"function","doc":"Preloads all associations on the given struct or structs. This is similar to Ecto.Query.preload/3 except it allows you to preload structs after they have been fetched from the database. In case the association was already loaded, preload won&#39;t attempt to reload it. Options :force - By default, Ecto won&#39;t preload associations that are already loaded. By setting this option to true, any existing association will be discarded and reloaded. :in_parallel - If the preloads must be done in parallel. It can only be performed when we have more than one preload and the repository is not in a transaction. Defaults to true. :prefix - the prefix to fetch preloads from. By default, queries will use the same prefix as the one in the given collection. This option allows the prefix to be changed. See the &quot;Shared options&quot; section at the module documentation for more options. Examples # Use a single atom to preload an association posts = Repo.preload posts, :comments # Use a list of atoms to preload multiple associations posts = Repo.preload posts, [:comments, :authors] # Use a keyword list to preload nested associations as well posts = Repo.preload posts, [comments: [:replies, :likes], authors: []] # Use a keyword list to customize how associations are queried posts = Repo.preload posts, [comments: from(c in Comment, order_by: c.published_at)] # Use a two-element tuple for a custom query and nested association definition query = from c in Comment, order_by: c.published_at posts = Repo.preload posts, [comments: {query, [:replies, :likes]}] The query given to preload may also preload its own associations. Callback implementation for Ecto.Repo.preload/3."},{"ref":"Fintech.Repo.html#prepare_query/3","title":"Fintech.Repo.prepare_query/3","type":"function","doc":"A user customizable callback invoked for query-based operations. This callback can be used to further modify the query and options before it is transformed and sent to the database. This callback is invoked for all query APIs, including the stream function, but it is not invoked for insert_all nor any of the schema functions. Callback implementation for Ecto.Repo.prepare_query/3."},{"ref":"Fintech.Repo.html#put_dynamic_repo/1","title":"Fintech.Repo.put_dynamic_repo/1","type":"function","doc":"Sets the dynamic repository to be used in further interactions. Sometimes you may want a single Ecto repository to talk to many different database instances. By default, when you call MyApp.Repo.start_link/1, it will start a repository with name MyApp.Repo. But if you want to start multiple repositories, you can give each of them a different name: MyApp.Repo.start_link(name: :tenant_foo, hostname: &quot;foo.example.com&quot;) MyApp.Repo.start_link(name: :tenant_bar, hostname: &quot;bar.example.com&quot;) You can also start repositories without names by explicitly setting the name to nil: MyApp.Repo.start_link(name: nil, hostname: &quot;temp.example.com&quot;) However, once the repository is started, you can&#39;t directly interact with it, since all operations in MyApp.Repo are sent by default to the repository named MyApp.Repo. You can change the default repo at compile time with: use Ecto.Repo, default_dynamic_repo: :name_of_repo Or you can change it anytime at runtime by calling put_dynamic_repo/1: MyApp.Repo.put_dynamic_repo(:tenant_foo) From this moment on, all future queries done by the current process will run on :tenant_foo. Note this feature is experimental and may be changed or removed in future releases. Callback implementation for Ecto.Repo.put_dynamic_repo/1."},{"ref":"Fintech.Repo.html#query/3","title":"Fintech.Repo.query/3","type":"function","doc":"A convenience function for SQL-based repositories that executes the given query. See Ecto.Adapters.SQL.query/4 for more information."},{"ref":"Fintech.Repo.html#query!/3","title":"Fintech.Repo.query!/3","type":"function","doc":"A convenience function for SQL-based repositories that executes the given query. See Ecto.Adapters.SQL.query!/4 for more information."},{"ref":"Fintech.Repo.html#rollback/1","title":"Fintech.Repo.rollback/1","type":"function","doc":"Rolls back the current transaction. The transaction will return the value given as {:error, value}. Callback implementation for Ecto.Repo.rollback/1."},{"ref":"Fintech.Repo.html#start_link/1","title":"Fintech.Repo.start_link/1","type":"function","doc":"Starts any connection pooling or supervision and return {:ok, pid} or just :ok if nothing needs to be done. Returns {:error, {:already_started, pid}} if the repo is already started or {:error, term} in case anything else goes wrong. Options See the configuration in the moduledoc for options shared between adapters, for adapter-specific configuration see the adapter&#39;s documentation. Callback implementation for Ecto.Repo.start_link/1."},{"ref":"Fintech.Repo.html#stop/1","title":"Fintech.Repo.stop/1","type":"function","doc":"Shuts down the repository. Callback implementation for Ecto.Repo.stop/1."},{"ref":"Fintech.Repo.html#stream/2","title":"Fintech.Repo.stream/2","type":"function","doc":"Returns a lazy enumerable that emits all entries from the data store matching the given query. SQL adapters, such as Postgres and MySQL, can only enumerate a stream inside a transaction. May raise Ecto.QueryError if query validation fails. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. :max_rows - The number of rows to load from the database as we stream. It is supported at least by Postgres and MySQL and defaults to 500. See the &quot;Shared options&quot; section at the module documentation for more options. Example # Fetch all post titles query = from p in Post, select: p.title stream = MyRepo.stream(query) MyRepo.transaction(fn() -&gt; Enum.to_list(stream) end) Callback implementation for Ecto.Repo.stream/2."},{"ref":"Fintech.Repo.html#to_sql/2","title":"Fintech.Repo.to_sql/2","type":"function","doc":"A convenience function for SQL-based repositories that translates the given query to SQL. See Ecto.Adapters.SQL.to_sql/3 for more information."},{"ref":"Fintech.Repo.html#transaction/2","title":"Fintech.Repo.transaction/2","type":"function","doc":"Runs the given function or Ecto.Multi inside a transaction. Use with function c:transaction/2 can be called with both a function of arity zero or one. The arity zero function will just be executed as is, while the arity one function will receive the repo of the transaction as its first argument, similar to Ecto.Multi.run. If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling c:rollback/1, this will immediately leave the function and return the value given to rollback as {:error, value}. A successful transaction returns the value returned by the function wrapped in a tuple as {:ok, value}. If c:transaction/2 is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed. Use with Ecto.Multi Besides functions transaction can be used with an Ecto.Multi struct. Transaction will be started, all operations applied and in case of success committed returning {:ok, changes}. In case of any errors the transaction will be rolled back and {:error, failed_operation, failed_value, changes_so_far} will be returned. You can read more about using transactions with Ecto.Multi as well as see some examples in the Ecto.Multi documentation. Options See the &quot;Shared options&quot; section at the module documentation for more options. Examples import Ecto.Changeset, only: [change: 2] MyRepo.transaction(fn -&gt; MyRepo.update!(change(alice, balance: alice.balance - 10)) MyRepo.update!(change(bob, balance: bob.balance + 10)) end) # When passing a function of arity 1, it receives the repository itself MyRepo.transaction(fn repo -&gt; repo.insert!(%Post{}) end) # Roll back a transaction explicitly MyRepo.transaction(fn -&gt; p = MyRepo.insert!(%Post{}) if not Editor.post_allowed?(p) do MyRepo.rollback(:posting_not_allowed) end end) # With Ecto.Multi Ecto.Multi.new |&gt; Ecto.Multi.insert(:post, %Post{}) |&gt; MyRepo.transaction Callback implementation for Ecto.Repo.transaction/2."},{"ref":"Fintech.Repo.html#update/2","title":"Fintech.Repo.update/2","type":"function","doc":"Updates a changeset using its primary key. A changeset is required as it is the only mechanism for tracking dirty changes. Only the fields present in the changes part of the changeset are sent to the database. Any other, in-memory changes done to the schema are ignored. If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised. If the struct cannot be found, Ecto.StaleEntryError will be raised. It returns {:ok, struct} if the struct has been successfully updated or {:error, changeset} if there was a validation or a known constraint error. Options :returning - selects which fields to return. It accepts a list of fields to be returned from the database. When true, returns all fields. When false, no extra fields are returned. It will always include all fields in read_after_writes. Not all databases support this option. :force - By default, if there are no changes in the changeset, c:update/2 is a no-op. By setting this option to true, update callbacks will always be executed, even if there are no changes (including timestamps). :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set any schemas. Also, the @schema_prefix for the parent record will override all default @schema_prefixs set in any child schemas for associations. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. See the &quot;Shared options&quot; section at the module documentation for more options. Example post = MyRepo.get!(Post, 42) post = Ecto.Changeset.change post, title: &quot;New title&quot; case MyRepo.update post do {:ok, struct} -&gt; # Updated with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.update/2."},{"ref":"Fintech.Repo.html#update!/2","title":"Fintech.Repo.update!/2","type":"function","doc":"Same as c:update/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.update!/2."},{"ref":"Fintech.Repo.html#update_all/3","title":"Fintech.Repo.update_all/3","type":"function","doc":"Updates all entries matching the given query with the given values. It returns a tuple containing the number of entries and any returned result as second element. The second element is nil by default unless a select is supplied in the update query. Note, however, not all databases support returning data from UPDATEs. Keep in mind this update_all will not update autogenerated fields like the updated_at columns. See Ecto.Query.update/3 for update operations that can be performed on fields. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.update_all(Post, set: [title: &quot;New title&quot;]) MyRepo.update_all(Post, inc: [visits: 1]) from(p in Post, where: p.id &lt; 10, select: p.visits) |&gt; MyRepo.update_all(set: [title: &quot;New title&quot;]) from(p in Post, where: p.id &lt; 10, update: [set: [title: &quot;New title&quot;]]) |&gt; MyRepo.update_all([]) from(p in Post, where: p.id &lt; 10, update: [set: [title: ^new_title]]) |&gt; MyRepo.update_all([]) from(p in Post, where: p.id &lt; 10, update: [set: [title: fragment(&quot;upper(?)&quot;, ^new_title)]]) |&gt; MyRepo.update_all([]) Callback implementation for Ecto.Repo.update_all/3."},{"ref":"Fintech.TransferAgent.html","title":"Fintech.TransferAgent","type":"module","doc":"This module provides the requirements to implement the transfer agent for a fintech company"},{"ref":"Fintech.TransferAgent.html#child_spec/1","title":"Fintech.TransferAgent.child_spec/1","type":"function","doc":"Returns a specification to start this module under a supervisor. See Supervisor."},{"ref":"Fintech.TransferAgent.html#handle_cast/2","title":"Fintech.TransferAgent.handle_cast/2","type":"function","doc":"Makes the async cast for a intra-transference"},{"ref":"Fintech.TransferAgent.html#init/1","title":"Fintech.TransferAgent.init/1","type":"function","doc":"Callback function when the GenServer is started"},{"ref":"Fintech.TransferAgent.html#start_link/1","title":"Fintech.TransferAgent.start_link/1","type":"function","doc":"Starts the GenServer"},{"ref":"Fintech.TransferAgent.html#transfer/1","title":"Fintech.TransferAgent.transfer/1","type":"function","doc":"Calls the GenServer for making a transference Examples iex&gt; alias Fintech.Transferences.Transference iex&gt; Fintech.TransferAgent.transfer({:intra, %Transference{account_id: 1, quantity: 100}}) :ok"},{"ref":"Fintech.TransferAgent.Config.html","title":"Fintech.TransferAgent.Config","type":"module","doc":"This module provides configuration for the transfer agent"},{"ref":"Fintech.TransferAgent.Config.html#get_transfer_list_types/0","title":"Fintech.TransferAgent.Config.get_transfer_list_types/0","type":"function","doc":"Gets the transfereces valid types for the transfer agent by config Examples iex&gt; Fintech.TransferAgent.Config.get_transfer_list_types() [:inter, :intra]"},{"ref":"Fintech.TransferAgent.Helpers.html","title":"Fintech.TransferAgent.Helpers","type":"module","doc":"This module provides the functions required to Transfer Agent"},{"ref":"Fintech.TransferAgent.Helpers.html#__using__/1","title":"Fintech.TransferAgent.Helpers.__using__/1","type":"macro","doc":"Function provides the use macro for the helper"},{"ref":"Fintech.TransferAgent.Helpers.html#helper/0","title":"Fintech.TransferAgent.Helpers.helper/0","type":"function","doc":"Function providing the desired imports"},{"ref":"Fintech.TransferAgent.Service.html","title":"Fintech.TransferAgent.Service","type":"module","doc":"This module provides the functions required to comunicate with the database"},{"ref":"Fintech.TransferAgent.Service.html#back_inter_transference/5","title":"Fintech.TransferAgent.Service.back_inter_transference/5","type":"function","doc":"Function in charge of backing the inter transference into database"},{"ref":"Fintech.TransferAgent.Service.html#back_transference/3","title":"Fintech.TransferAgent.Service.back_transference/3","type":"function","doc":"Function in charge of backing the transference into database"},{"ref":"Fintech.TransferAgent.Service.html#check_account/4","title":"Fintech.TransferAgent.Service.check_account/4","type":"function","doc":"Function in charge of checking account from database"},{"ref":"Fintech.TransferAgent.Service.html#check_failure/4","title":"Fintech.TransferAgent.Service.check_failure/4","type":"function","doc":"Function simulating the failure rate"},{"ref":"Fintech.TransferAgent.Service.html#check_transference/5","title":"Fintech.TransferAgent.Service.check_transference/5","type":"function","doc":"Function in charge of validating the transference"},{"ref":"Fintech.TransferAgent.Service.html#get_account_with_transferences/2","title":"Fintech.TransferAgent.Service.get_account_with_transferences/2","type":"function","doc":"Function in charge of getting from database the data required for the update operation"},{"ref":"Fintech.TransferAgent.Service.html#get_account_with_transferences_inter/4","title":"Fintech.TransferAgent.Service.get_account_with_transferences_inter/4","type":"function","doc":"Function in charge of getting from database the data required for the update operation"},{"ref":"Fintech.Transferences.html","title":"Fintech.Transferences","type":"module","doc":"The Transferences context."},{"ref":"Fintech.Transferences.html#change_transference/1","title":"Fintech.Transferences.change_transference/1","type":"function","doc":"Returns an %Ecto.Changeset{} for tracking transference changes. Examples iex&gt; change_transference(transference) %Ecto.Changeset{source: %Transference{}}"},{"ref":"Fintech.Transferences.html#create_transference/1","title":"Fintech.Transferences.create_transference/1","type":"function","doc":"Creates a transference. Examples iex&gt; create_transference(%{field: value}) {:ok, %Transference{}} iex&gt; create_transference(%{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Transferences.html#delete_transference/1","title":"Fintech.Transferences.delete_transference/1","type":"function","doc":"Deletes a Transference. Examples iex&gt; delete_transference(transference) {:ok, %Transference{}} iex&gt; delete_transference(transference) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Transferences.html#get_transference!/1","title":"Fintech.Transferences.get_transference!/1","type":"function","doc":"Gets a single transference. Raises Ecto.NoResultsError if the Transference does not exist. Examples iex&gt; get_transference!(123) %Transference{} iex&gt; get_transference!(456) ** (Ecto.NoResultsError)"},{"ref":"Fintech.Transferences.html#list_transferences/0","title":"Fintech.Transferences.list_transferences/0","type":"function","doc":"Returns the list of transferences. Examples iex&gt; list_transferences() [%Transference{}, ...]"},{"ref":"Fintech.Transferences.html#update_transference/2","title":"Fintech.Transferences.update_transference/2","type":"function","doc":"Updates a transference. Examples iex&gt; update_transference(transference, %{field: new_value}) {:ok, %Transference{}} iex&gt; update_transference(transference, %{field: bad_value}) {:error, %Ecto.Changeset{}}"},{"ref":"Fintech.Transferences.Transference.html","title":"Fintech.Transferences.Transference","type":"module","doc":""},{"ref":"FintechWeb.html","title":"FintechWeb","type":"module","doc":"The entrypoint for defining your web interface, such as controllers, views, channels and so on. This can be used in your application as: use FintechWeb, :controller use FintechWeb, :view The definitions below will be executed for every view, controller, etc, so keep them short and clean, focused on imports, uses and aliases. Do NOT define functions inside the quoted expressions below. Instead, define any helper function in modules and import those modules here."},{"ref":"FintechWeb.html#__using__/1","title":"FintechWeb.__using__/1","type":"macro","doc":"When used, dispatch to the appropriate controller/view/etc."},{"ref":"FintechWeb.html#channel/0","title":"FintechWeb.channel/0","type":"function","doc":""},{"ref":"FintechWeb.html#controller/0","title":"FintechWeb.controller/0","type":"function","doc":""},{"ref":"FintechWeb.html#router/0","title":"FintechWeb.router/0","type":"function","doc":""},{"ref":"FintechWeb.html#view/0","title":"FintechWeb.view/0","type":"function","doc":""},{"ref":"FintechWeb.AccountController.html","title":"FintechWeb.AccountController","type":"module","doc":""},{"ref":"FintechWeb.AccountController.html#create/2","title":"FintechWeb.AccountController.create/2","type":"function","doc":""},{"ref":"FintechWeb.AccountController.html#delete/2","title":"FintechWeb.AccountController.delete/2","type":"function","doc":""},{"ref":"FintechWeb.AccountController.html#edit/2","title":"FintechWeb.AccountController.edit/2","type":"function","doc":""},{"ref":"FintechWeb.AccountController.html#index/2","title":"FintechWeb.AccountController.index/2","type":"function","doc":""},{"ref":"FintechWeb.AccountController.html#new/2","title":"FintechWeb.AccountController.new/2","type":"function","doc":""},{"ref":"FintechWeb.AccountController.html#show/2","title":"FintechWeb.AccountController.show/2","type":"function","doc":""},{"ref":"FintechWeb.AccountController.html#update/2","title":"FintechWeb.AccountController.update/2","type":"function","doc":""},{"ref":"FintechWeb.AccountView.html","title":"FintechWeb.AccountView","type":"module","doc":""},{"ref":"FintechWeb.AccountView.html#__phoenix_recompile__?/0","title":"FintechWeb.AccountView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"FintechWeb.AccountView.html#__resource__/0","title":"FintechWeb.AccountView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"FintechWeb.AccountView.html#__templates__/0","title":"FintechWeb.AccountView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"FintechWeb.AccountView.html#render/2","title":"FintechWeb.AccountView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"FintechWeb.AccountView.html#template_not_found/2","title":"FintechWeb.AccountView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"FintechWeb.BankController.html","title":"FintechWeb.BankController","type":"module","doc":""},{"ref":"FintechWeb.BankController.html#create/2","title":"FintechWeb.BankController.create/2","type":"function","doc":""},{"ref":"FintechWeb.BankController.html#delete/2","title":"FintechWeb.BankController.delete/2","type":"function","doc":""},{"ref":"FintechWeb.BankController.html#edit/2","title":"FintechWeb.BankController.edit/2","type":"function","doc":""},{"ref":"FintechWeb.BankController.html#index/2","title":"FintechWeb.BankController.index/2","type":"function","doc":""},{"ref":"FintechWeb.BankController.html#new/2","title":"FintechWeb.BankController.new/2","type":"function","doc":""},{"ref":"FintechWeb.BankController.html#show/2","title":"FintechWeb.BankController.show/2","type":"function","doc":""},{"ref":"FintechWeb.BankController.html#update/2","title":"FintechWeb.BankController.update/2","type":"function","doc":""},{"ref":"FintechWeb.BankView.html","title":"FintechWeb.BankView","type":"module","doc":""},{"ref":"FintechWeb.BankView.html#__phoenix_recompile__?/0","title":"FintechWeb.BankView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"FintechWeb.BankView.html#__resource__/0","title":"FintechWeb.BankView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"FintechWeb.BankView.html#__templates__/0","title":"FintechWeb.BankView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"FintechWeb.BankView.html#render/2","title":"FintechWeb.BankView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"FintechWeb.BankView.html#template_not_found/2","title":"FintechWeb.BankView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"FintechWeb.CustomerController.html","title":"FintechWeb.CustomerController","type":"module","doc":""},{"ref":"FintechWeb.CustomerController.html#create/2","title":"FintechWeb.CustomerController.create/2","type":"function","doc":""},{"ref":"FintechWeb.CustomerController.html#delete/2","title":"FintechWeb.CustomerController.delete/2","type":"function","doc":""},{"ref":"FintechWeb.CustomerController.html#edit/2","title":"FintechWeb.CustomerController.edit/2","type":"function","doc":""},{"ref":"FintechWeb.CustomerController.html#index/2","title":"FintechWeb.CustomerController.index/2","type":"function","doc":""},{"ref":"FintechWeb.CustomerController.html#new/2","title":"FintechWeb.CustomerController.new/2","type":"function","doc":""},{"ref":"FintechWeb.CustomerController.html#show/2","title":"FintechWeb.CustomerController.show/2","type":"function","doc":""},{"ref":"FintechWeb.CustomerController.html#update/2","title":"FintechWeb.CustomerController.update/2","type":"function","doc":""},{"ref":"FintechWeb.CustomerView.html","title":"FintechWeb.CustomerView","type":"module","doc":""},{"ref":"FintechWeb.CustomerView.html#__phoenix_recompile__?/0","title":"FintechWeb.CustomerView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"FintechWeb.CustomerView.html#__resource__/0","title":"FintechWeb.CustomerView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"FintechWeb.CustomerView.html#__templates__/0","title":"FintechWeb.CustomerView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"FintechWeb.CustomerView.html#render/2","title":"FintechWeb.CustomerView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"FintechWeb.CustomerView.html#template_not_found/2","title":"FintechWeb.CustomerView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"FintechWeb.Endpoint.html","title":"FintechWeb.Endpoint","type":"module","doc":""},{"ref":"FintechWeb.Endpoint.html#broadcast/3","title":"FintechWeb.Endpoint.broadcast/3","type":"function","doc":"Broadcasts a msg as event in the given topic. Callback implementation for Phoenix.Endpoint.broadcast/3."},{"ref":"FintechWeb.Endpoint.html#broadcast!/3","title":"FintechWeb.Endpoint.broadcast!/3","type":"function","doc":"Broadcasts a msg as event in the given topic. Raises in case of failures. Callback implementation for Phoenix.Endpoint.broadcast!/3."},{"ref":"FintechWeb.Endpoint.html#broadcast_from/4","title":"FintechWeb.Endpoint.broadcast_from/4","type":"function","doc":"Broadcasts a msg from the given from as event in the given topic. Callback implementation for Phoenix.Endpoint.broadcast_from/4."},{"ref":"FintechWeb.Endpoint.html#broadcast_from!/4","title":"FintechWeb.Endpoint.broadcast_from!/4","type":"function","doc":"Broadcasts a msg from the given from as event in the given topic. Raises in case of failures. Callback implementation for Phoenix.Endpoint.broadcast_from!/4."},{"ref":"FintechWeb.Endpoint.html#call/2","title":"FintechWeb.Endpoint.call/2","type":"function","doc":"Callback implementation for Plug.call/2."},{"ref":"FintechWeb.Endpoint.html#child_spec/1","title":"FintechWeb.Endpoint.child_spec/1","type":"function","doc":"Returns the child specification to start the endpoint under a supervision tree."},{"ref":"FintechWeb.Endpoint.html#config/2","title":"FintechWeb.Endpoint.config/2","type":"function","doc":"Returns the endpoint configuration for key Returns default if the key does not exist."},{"ref":"FintechWeb.Endpoint.html#config_change/2","title":"FintechWeb.Endpoint.config_change/2","type":"function","doc":"Reloads the configuration given the application environment changes."},{"ref":"FintechWeb.Endpoint.html#host/0","title":"FintechWeb.Endpoint.host/0","type":"function","doc":"Returns the host for the given endpoint."},{"ref":"FintechWeb.Endpoint.html#init/1","title":"FintechWeb.Endpoint.init/1","type":"function","doc":"Callback implementation for Plug.init/1."},{"ref":"FintechWeb.Endpoint.html#instrument/3","title":"FintechWeb.Endpoint.instrument/3","type":"macro","doc":"Instruments the given function. event is the event identifier (usually an atom) that specifies which instrumenting function to call in the instrumenter modules. runtime is metadata to be associated with the event at runtime (e.g., the query being issued if the event to instrument is a DB query). Examples instrument :render_view, %{view: &quot;index.html&quot;}, fn -&gt; render(conn, &quot;index.html&quot;) end"},{"ref":"FintechWeb.Endpoint.html#path/1","title":"FintechWeb.Endpoint.path/1","type":"function","doc":"Generates the path information when routing to this endpoint."},{"ref":"FintechWeb.Endpoint.html#script_name/0","title":"FintechWeb.Endpoint.script_name/0","type":"function","doc":"Generates the script name."},{"ref":"FintechWeb.Endpoint.html#start_link/1","title":"FintechWeb.Endpoint.start_link/1","type":"function","doc":"Starts the endpoint supervision tree."},{"ref":"FintechWeb.Endpoint.html#static_integrity/1","title":"FintechWeb.Endpoint.static_integrity/1","type":"function","doc":"Generates a base64-encoded cryptographic hash (sha512) to a static file in priv/static. Meant to be used for Subresource Integrity with CDNs."},{"ref":"FintechWeb.Endpoint.html#static_lookup/1","title":"FintechWeb.Endpoint.static_lookup/1","type":"function","doc":"Returns a two item tuple with the first item being the static_path and the second item being the static_integrity."},{"ref":"FintechWeb.Endpoint.html#static_path/1","title":"FintechWeb.Endpoint.static_path/1","type":"function","doc":"Generates a route to a static file in priv/static."},{"ref":"FintechWeb.Endpoint.html#static_url/0","title":"FintechWeb.Endpoint.static_url/0","type":"function","doc":"Generates the static URL without any path information. It uses the configuration under :static_url to generate such. It falls back to :url if :static_url is not set."},{"ref":"FintechWeb.Endpoint.html#struct_url/0","title":"FintechWeb.Endpoint.struct_url/0","type":"function","doc":"Generates the endpoint base URL but as a URI struct. It uses the configuration under :url to generate such. Useful for manipulating the URL data and passing it to URL helpers."},{"ref":"FintechWeb.Endpoint.html#subscribe/1","title":"FintechWeb.Endpoint.subscribe/1","type":"function","doc":""},{"ref":"FintechWeb.Endpoint.html#subscribe/3","title":"FintechWeb.Endpoint.subscribe/3","type":"function","doc":""},{"ref":"FintechWeb.Endpoint.html#unsubscribe/1","title":"FintechWeb.Endpoint.unsubscribe/1","type":"function","doc":"Unsubscribes the caller from the given topic. Callback implementation for Phoenix.Endpoint.unsubscribe/1."},{"ref":"FintechWeb.Endpoint.html#url/0","title":"FintechWeb.Endpoint.url/0","type":"function","doc":"Generates the endpoint base URL without any path information. It uses the configuration under :url to generate such."},{"ref":"FintechWeb.ErrorHelpers.html","title":"FintechWeb.ErrorHelpers","type":"module","doc":"Conveniences for translating and building error messages."},{"ref":"FintechWeb.ErrorHelpers.html#error_tag/2","title":"FintechWeb.ErrorHelpers.error_tag/2","type":"function","doc":"Generates tag for inlined form input errors."},{"ref":"FintechWeb.ErrorHelpers.html#translate_error/1","title":"FintechWeb.ErrorHelpers.translate_error/1","type":"function","doc":"Translates an error message using gettext."},{"ref":"FintechWeb.ErrorView.html","title":"FintechWeb.ErrorView","type":"module","doc":""},{"ref":"FintechWeb.ErrorView.html#__phoenix_recompile__?/0","title":"FintechWeb.ErrorView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"FintechWeb.ErrorView.html#__resource__/0","title":"FintechWeb.ErrorView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"FintechWeb.ErrorView.html#__templates__/0","title":"FintechWeb.ErrorView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"FintechWeb.ErrorView.html#render/2","title":"FintechWeb.ErrorView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"FintechWeb.ErrorView.html#template_not_found/2","title":"FintechWeb.ErrorView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"FintechWeb.Gettext.html","title":"FintechWeb.Gettext","type":"module","doc":"A module providing Internationalization with a gettext-based API. By using Gettext, your module gains a set of macros for translations, for example: import FintechWeb.Gettext # Simple translation gettext(&quot;Here is the string to translate&quot;) # Plural translation ngettext(&quot;Here is the string to translate&quot;, &quot;Here are the strings to translate&quot;, 3) # Domain-based translation dgettext(&quot;errors&quot;, &quot;Here is the error message to translate&quot;) See the Gettext Docs for detailed usage."},{"ref":"FintechWeb.Gettext.html#dgettext/3","title":"FintechWeb.Gettext.dgettext/3","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#dgettext_noop/2","title":"FintechWeb.Gettext.dgettext_noop/2","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#dngettext/5","title":"FintechWeb.Gettext.dngettext/5","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#dngettext_noop/3","title":"FintechWeb.Gettext.dngettext_noop/3","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#gettext/2","title":"FintechWeb.Gettext.gettext/2","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#gettext_comment/1","title":"FintechWeb.Gettext.gettext_comment/1","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#gettext_noop/1","title":"FintechWeb.Gettext.gettext_noop/1","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#handle_missing_bindings/2","title":"FintechWeb.Gettext.handle_missing_bindings/2","type":"function","doc":"Default handling for missing bindings. This function is called when there are missing bindings in a translation. It takes a Gettext.MissingBindingsError struct and the translation with the wrong bindings left as is with the %{} syntax. For example, if something like this is called: MyApp.Gettext.gettext(&quot;Hello %{name}, welcome to %{country}&quot;, name: &quot;Jane&quot;, country: &quot;Italy&quot;) and our it/LC_MESSAGES/default.po looks like this: msgid &quot;Hello %{name}, welcome to %{country}&quot; msgstr &quot;Ciao %{name}, benvenuto in %{cowntry}&quot; # (typo) then Gettext will call: MyApp.Gettext.handle_missing_bindings(exception, &quot;Ciao Jane, benvenuto in %{cowntry}&quot;) where exception is a struct that looks like this: %Gettext.MissingBindingsError{ backend: MyApp.Gettext, domain: &quot;default&quot;, locale: &quot;it&quot;, msgid: &quot;Hello %{name}, welcome to %{country}&quot;, bindings: [:country], } The return value of the c:handle_missing_bindings/2 callback is used as the translated string that the translation macros and functions return. The default implementation for this function uses Logger.error/1 to warn about the missing binding and returns the translated message with the incomplete bindings. This function can be overridden. For example, to raise when there are missing bindings: def handle_missing_bindings(exception, _incomplete) do raise exception end Callback implementation for Gettext.Backend.handle_missing_bindings/2."},{"ref":"FintechWeb.Gettext.html#handle_missing_plural_translation/6","title":"FintechWeb.Gettext.handle_missing_plural_translation/6","type":"function","doc":"Default handling for plural translations with a missing translation. Same as c:handle_missing_translation/4, but for plural translations. In this case, n is the number used for pluralizing the translated string. Callback implementation for Gettext.Backend.handle_missing_plural_translation/6."},{"ref":"FintechWeb.Gettext.html#handle_missing_translation/4","title":"FintechWeb.Gettext.handle_missing_translation/4","type":"function","doc":"Default handling for translations with a missing translation. When a Gettext function/macro is called with a string to translate into a locale but that locale doesn&#39;t provide a translation for that string, this callback is invoked. msgid is the string that Gettext tried to translate. This function should return {:ok, translated} if a translation can be fetched or constructed for the given string, or {:default, msgid} otherwise. Callback implementation for Gettext.Backend.handle_missing_translation/4."},{"ref":"FintechWeb.Gettext.html#lgettext/4","title":"FintechWeb.Gettext.lgettext/4","type":"function","doc":""},{"ref":"FintechWeb.Gettext.html#lngettext/6","title":"FintechWeb.Gettext.lngettext/6","type":"function","doc":""},{"ref":"FintechWeb.Gettext.html#ngettext/4","title":"FintechWeb.Gettext.ngettext/4","type":"macro","doc":""},{"ref":"FintechWeb.Gettext.html#ngettext_noop/2","title":"FintechWeb.Gettext.ngettext_noop/2","type":"macro","doc":""},{"ref":"FintechWeb.LayoutView.html","title":"FintechWeb.LayoutView","type":"module","doc":""},{"ref":"FintechWeb.LayoutView.html#__phoenix_recompile__?/0","title":"FintechWeb.LayoutView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"FintechWeb.LayoutView.html#__resource__/0","title":"FintechWeb.LayoutView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"FintechWeb.LayoutView.html#__templates__/0","title":"FintechWeb.LayoutView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"FintechWeb.LayoutView.html#render/2","title":"FintechWeb.LayoutView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"FintechWeb.LayoutView.html#template_not_found/2","title":"FintechWeb.LayoutView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"FintechWeb.PageController.html","title":"FintechWeb.PageController","type":"module","doc":""},{"ref":"FintechWeb.PageController.html#index/2","title":"FintechWeb.PageController.index/2","type":"function","doc":""},{"ref":"FintechWeb.PageView.html","title":"FintechWeb.PageView","type":"module","doc":""},{"ref":"FintechWeb.PageView.html#__phoenix_recompile__?/0","title":"FintechWeb.PageView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"FintechWeb.PageView.html#__resource__/0","title":"FintechWeb.PageView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"FintechWeb.PageView.html#__templates__/0","title":"FintechWeb.PageView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"FintechWeb.PageView.html#render/2","title":"FintechWeb.PageView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"FintechWeb.PageView.html#template_not_found/2","title":"FintechWeb.PageView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"FintechWeb.Router.html","title":"FintechWeb.Router","type":"module","doc":""},{"ref":"FintechWeb.Router.html#api/2","title":"FintechWeb.Router.api/2","type":"function","doc":""},{"ref":"FintechWeb.Router.html#browser/2","title":"FintechWeb.Router.browser/2","type":"function","doc":""},{"ref":"FintechWeb.Router.html#call/2","title":"FintechWeb.Router.call/2","type":"function","doc":"Callback invoked by Plug on every request."},{"ref":"FintechWeb.Router.html#init/1","title":"FintechWeb.Router.init/1","type":"function","doc":"Callback required by Plug that initializes the router for serving web requests."},{"ref":"FintechWeb.Router.Helpers.html","title":"FintechWeb.Router.Helpers","type":"module","doc":"Module with named helpers generated from FintechWeb.Router."},{"ref":"FintechWeb.Router.Helpers.html#account_path/2","title":"FintechWeb.Router.Helpers.account_path/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#account_path/3","title":"FintechWeb.Router.Helpers.account_path/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#account_path/4","title":"FintechWeb.Router.Helpers.account_path/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#account_url/2","title":"FintechWeb.Router.Helpers.account_url/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#account_url/3","title":"FintechWeb.Router.Helpers.account_url/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#account_url/4","title":"FintechWeb.Router.Helpers.account_url/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#bank_path/2","title":"FintechWeb.Router.Helpers.bank_path/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#bank_path/3","title":"FintechWeb.Router.Helpers.bank_path/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#bank_path/4","title":"FintechWeb.Router.Helpers.bank_path/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#bank_url/2","title":"FintechWeb.Router.Helpers.bank_url/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#bank_url/3","title":"FintechWeb.Router.Helpers.bank_url/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#bank_url/4","title":"FintechWeb.Router.Helpers.bank_url/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#customer_path/2","title":"FintechWeb.Router.Helpers.customer_path/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#customer_path/3","title":"FintechWeb.Router.Helpers.customer_path/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#customer_path/4","title":"FintechWeb.Router.Helpers.customer_path/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#customer_url/2","title":"FintechWeb.Router.Helpers.customer_url/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#customer_url/3","title":"FintechWeb.Router.Helpers.customer_url/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#customer_url/4","title":"FintechWeb.Router.Helpers.customer_url/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#page_path/2","title":"FintechWeb.Router.Helpers.page_path/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#page_path/3","title":"FintechWeb.Router.Helpers.page_path/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#page_url/2","title":"FintechWeb.Router.Helpers.page_url/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#page_url/3","title":"FintechWeb.Router.Helpers.page_url/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#path/2","title":"FintechWeb.Router.Helpers.path/2","type":"function","doc":"Generates the path information including any necessary prefix."},{"ref":"FintechWeb.Router.Helpers.html#static_integrity/2","title":"FintechWeb.Router.Helpers.static_integrity/2","type":"function","doc":"Generates an integrity hash to a static asset given its file path."},{"ref":"FintechWeb.Router.Helpers.html#static_path/2","title":"FintechWeb.Router.Helpers.static_path/2","type":"function","doc":"Generates path to a static asset given its file path."},{"ref":"FintechWeb.Router.Helpers.html#static_url/2","title":"FintechWeb.Router.Helpers.static_url/2","type":"function","doc":"Generates url to a static asset given its file path."},{"ref":"FintechWeb.Router.Helpers.html#transference_path/2","title":"FintechWeb.Router.Helpers.transference_path/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#transference_path/3","title":"FintechWeb.Router.Helpers.transference_path/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#transference_path/4","title":"FintechWeb.Router.Helpers.transference_path/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#transference_url/2","title":"FintechWeb.Router.Helpers.transference_url/2","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#transference_url/3","title":"FintechWeb.Router.Helpers.transference_url/3","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#transference_url/4","title":"FintechWeb.Router.Helpers.transference_url/4","type":"function","doc":""},{"ref":"FintechWeb.Router.Helpers.html#url/1","title":"FintechWeb.Router.Helpers.url/1","type":"function","doc":"Generates the connection/endpoint base URL without any path information."},{"ref":"FintechWeb.TransferenceController.html","title":"FintechWeb.TransferenceController","type":"module","doc":""},{"ref":"FintechWeb.TransferenceController.html#create/2","title":"FintechWeb.TransferenceController.create/2","type":"function","doc":""},{"ref":"FintechWeb.TransferenceController.html#delete/2","title":"FintechWeb.TransferenceController.delete/2","type":"function","doc":""},{"ref":"FintechWeb.TransferenceController.html#edit/2","title":"FintechWeb.TransferenceController.edit/2","type":"function","doc":""},{"ref":"FintechWeb.TransferenceController.html#index/2","title":"FintechWeb.TransferenceController.index/2","type":"function","doc":""},{"ref":"FintechWeb.TransferenceController.html#new/2","title":"FintechWeb.TransferenceController.new/2","type":"function","doc":""},{"ref":"FintechWeb.TransferenceController.html#show/2","title":"FintechWeb.TransferenceController.show/2","type":"function","doc":""},{"ref":"FintechWeb.TransferenceController.html#update/2","title":"FintechWeb.TransferenceController.update/2","type":"function","doc":""},{"ref":"FintechWeb.TransferenceView.html","title":"FintechWeb.TransferenceView","type":"module","doc":""},{"ref":"FintechWeb.TransferenceView.html#__phoenix_recompile__?/0","title":"FintechWeb.TransferenceView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"FintechWeb.TransferenceView.html#__resource__/0","title":"FintechWeb.TransferenceView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"FintechWeb.TransferenceView.html#__templates__/0","title":"FintechWeb.TransferenceView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"FintechWeb.TransferenceView.html#render/2","title":"FintechWeb.TransferenceView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"FintechWeb.TransferenceView.html#template_not_found/2","title":"FintechWeb.TransferenceView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"FintechWeb.UserSocket.html","title":"FintechWeb.UserSocket","type":"module","doc":""},{"ref":"FintechWeb.UserSocket.html#connect/3","title":"FintechWeb.UserSocket.connect/3","type":"function","doc":"Callback implementation for Phoenix.Socket.connect/3."},{"ref":"FintechWeb.UserSocket.html#id/1","title":"FintechWeb.UserSocket.id/1","type":"function","doc":"Identifies the socket connection. Socket IDs are topics that allow you to identify all sockets for a given user: def id(socket), do: &quot;users_socket:\#{socket.assigns.user_id}&quot; Would allow you to broadcast a &quot;disconnect&quot; event and terminate all active sockets and channels for a given user: MyApp.Endpoint.broadcast(&quot;users_socket:&quot; &lt;&gt; user.id, &quot;disconnect&quot;, %{}) Returning nil makes this socket anonymous. Callback implementation for Phoenix.Socket.id/1."},{"ref":"readme.html","title":"Fintech","type":"extras","doc":"Fintech"},{"ref":"readme.html#postgres","title":"Fintech - Postgres","type":"extras","doc":"We need a username: postgres password: postgres to test this project"},{"ref":"readme.html#starting-phoenix-server","title":"Fintech - Starting Phoenix server:","type":"extras","doc":"Install dependencies with: mix deps.get Create and migrate your database with: mix ecto.setup Install Node.js dependencies with: cd assets &amp;&amp; npm install Start Phoenix endpoint with: mix phx.server Now you can visit localhost:4000 from your browser."},{"ref":"readme.html#purpose","title":"Fintech - Purpose","type":"extras","doc":"The purpose of this project is to acquire knowledge in phoenix framework as well as also fulfill Pagantis technical test."},{"ref":"readme.html#implementation","title":"Fintech - Implementation","type":"extras","doc":"Entities Banks This entity holds the representation for a bank. Customers This entity holds the representation for a customer from a bank. Accounts This entity holds the representation for an account from a customer. Transferences This entity holds the representation for a transference from an account. TransferAgent Testing Test the transfer Agent with iex interface: &#39;iex -S phx.server&#39; &#39;{:ok, _} = Fintech.TransferAgent.start_link([])&#39; &#39;alias Fintech.Transferences.Transference&#39; &#39;Fintech.TransferAgent.transfer({:intra, %Transference{account_id: 1, quantity: 100}})&#39; Metrics I listened to a recent podcast from OvermindDL1 a well known user from the Erlang/Elixir community, and core team member for: ldap_ex and permission_ex. He mentioned some useful tools one being telemetry from Erlang which I haven&#39;t used it since this same project. I couldn’t imagine the setup for telemetry was that easy, the potential and configuration from this dependency is huge. Logging I used Logger to perform the required logging for specific parts for the project. Deployment I used distilery for deployment of this project. I haven&#39;t tested yet the new deployment system from elixir 1.9 but I would check it in the future for sure. Also I would check out how to integrate docker with the distilery image. Walthrough: # start a shell, like &#39;iex -S mix&#39; _build/dev/rel/fintech/bin/fintech.bat console # start in the foreground, like &#39;mix run --no-halt&#39; _build/dev/rel/fintech/bin/fintech.bat foreground # start in the background, must be stopped with the &#39;stop&#39; command _build/dev/rel/fintech/bin/fintech.bat start If you started a release elsewhere, and wish to connect to it: # connects a local shell to the running node _build/dev/rel/fintech/bin/fintech.bat remote_console # connects directly to the running node&#39;s console _build/dev/rel/fintech/bin/fintech.bat attach For a complete listing of commands and their use: _build/dev/rel/fintech/bin/fintech.bat help Docs Never used exdocs in any of my personal project, but is really easy to use and not gonna lie it&#39;s awesome. Just by using documenting attributes in the project you can create this same documentation. Testing I have added some extra validations for the entities changesets I have never used before. I had to comment some of the generated tests because I couldn&#39;t fix them. I haven&#39;t used ecto associations well enough. Also this whole project the main difficulty for me has been the ecto associations. I never used doctests before and I tested some trivial functions because I didn&#39;t know how to test a database operating function. I found doctest really easy to setup and to integrate into the docs."},{"ref":"readme.html#questions","title":"Fintech - Questions:","type":"extras","doc":"How would you improve your solution? What would be the next steps? My whole project can be improved in every technical area. I don&#39;t think I have the knowledge to say any of the areas I tried to implement are efficient enough or good enough. I still have a long journey into the Elixir path. I still have to implement the money inyection into a second account. I will need to test the kind of approach database-wise I would follow to achieve that. One would be just adding the account id, and the other one would be with an association. The next step would be to assign into the database the user. Although we can do transferences via iex and calling the GenServer, it would be really nice to do transferences from the transference new view from phoenix. However we first need to assign the user into the actual phoenix conn. I have done previously a project using github oauth The-Complete-Elixir-and-Phoenix-Bootcamp related but not the solution we need. We would rather need a login form and assign that user into the phoenix connection. After implementation, is there any design decision that you would have done differently? We could create another entity: transaction. This will be in charge of doing the micro transferences from a single transference when a full transference is out of the established scope. How would you adapt your solution if transfers are not instantaneous? I would use the GenServer that I created on the Transfer Agent and use the state to save the state of the transferences being taken place. This solution would use an existing implementation. In one hand we could reimplement the solution by using a cached solution using cachex, which is based by ETS and was also highlighted by OvermindDL1, if we are in need of a faster solution. On the other hand we can use a disk based solution if we aren&#39;t in the need of window of response, this would be implementing a disk based batch for night execution."},{"ref":"readme.html#disclaimer","title":"Fintech - Disclaimer","type":"extras","doc":"I have an exam on 28 of november, so I can’t work any further into this project. The most time consuming part from this technical test was ecto associations and how to work with them. The remaining parts were also hard because was the first time I had used them but I found it fairly easy to make them working. This project was done during the weekend from the spare hours I could get from studying and working from my second job as waiter for &#39;El mentidero de la villa&#39;."},{"ref":"readme.html#prerequisites","title":"Fintech - Prerequisites","type":"extras","doc":"To run this project you need: Erlang: The programming language http://www.erlang.org/ Elixir: The programming language https://elixir-lang.org/"},{"ref":"readme.html#built-within","title":"Fintech - Built within","type":"extras","doc":"Elixir: The programming language https://elixir-lang.org/ Phoenix: Web framework in Elixir http://www.phoenixframework.org/"},{"ref":"readme.html#authors","title":"Fintech - Authors","type":"extras","doc":"Alberto Revuelta Arribas - initial workkamigari"},{"ref":"readme.html#license","title":"Fintech - License","type":"extras","doc":"This project is licensed under the License - see the LICENSE.md file for details."}]